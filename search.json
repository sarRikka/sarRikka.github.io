[{"title":"挖矿教程（小白版）","date":"2021-10-15T16:00:00.000Z","url":"/2021/10/16/%E6%8C%96%E7%9F%BF%E6%95%99%E7%A8%8B%EF%BC%88%E5%B0%8F%E7%99%BD%E7%89%88%EF%BC%89/","tags":[["教程","/tags/%E6%95%99%E7%A8%8B/"]],"categories":[["undefined",""]],"content":"1.选择一个矿池完成注册—–（点击传送门）在官网注册好之后，这是注册子账户和配置矿机的图文教程（点击传送门），在完成相关的注册和子账户的配置后，我们进入下一步。 2.下载挖矿软件，这里推荐用轻松矿工，软件下载地址。 直接点开安装软件，注意勾选的选项 3.轻松矿工下载好了之后，点击运行 可以将虚拟内存设置高一些 矿工名可以随便打 币种我这选择了CKB 钱包就是我们之前创建的子账户，将子账户的名字复制粘贴进钱包那。 矿池星火，内壳第一个就好。 之后点击开始挖矿，在这可以查看收益 这是我用笔记本挖了10min获得的CKB币，注意别用笔记本挖矿，很伤寿命！！！我只是挖着玩玩。 接下来大家可以试着获得属于自己的虚拟货币了~"},{"title":"算法导论第三版答案","date":"2021-10-15T16:00:00.000Z","url":"/2021/10/16/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC%E4%B8%89%E7%89%88%E7%AD%94%E6%A1%88/","tags":[["资源","/tags/%E8%B5%84%E6%BA%90/"]],"categories":[["undefined",""]],"content":" 链接：提取码：rikk"},{"title":"线段树实现与应用","date":"2021-10-15T16:00:00.000Z","url":"/2021/10/16/%E7%BA%BF%E6%AE%B5%E6%A0%91--%E6%A6%82%E5%BF%B5+%E6%A8%A1%E6%9D%BF+%E5%85%A5%E9%97%A8%E9%A2%98/","tags":[["c++","/tags/c/"],["算法","/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["undefined",""]],"content":"引子子问题–1给出n个数，m次问询，每次问询给出一个范围l、r，求区间l–r的总和很容易想到用前缀和可以解决 O(n) 子问题–2给出n个数，m次修改，每次给出一个范围l、r和一个值k，将区间l—r的数全部+k，m次修改后，再问询1次求区间l–r的总和也可以想到这用差分就能解决 O(n) 最后将这两个问题结合起来，给出n个数，m次操作，操作有两种一个是将区间l–r的值+k,一个是询问区间l–r的总和。 这个问题与之前不同的地方是，之前想要求一个范围只需处理一次数据算前缀和，然后数据不变，可以一劳永逸算出多次查询，但现在用原本的方法的话，每当数据更新一次，就必须再算一次前缀和 O(n^2)。 那有没有一些方法能够优化最后一种问题呢？ 现在就到了线段树出场的时候啦~ 线段树基本概念1.线段树是一颗二叉树 2.线段树的每一个结点由左端点，右端点，范围值组成、懒标记（子树的待加值） 3.线段树核心思想是二分 下面来看看线段树长啥样 特征：仔细观察一下会发现这其实是一个二分的一个过程，对于一个结点k的左子树它的左儿子的序号为2k,右儿子的序号为2k+1。设mid=(l+r)/2,然后左儿子的范围为[父节点l,父节点mid]，右儿子的范围为[父节点mid,父节点r]。 在这着重介绍下懒标记 每当我们修改一个范围内的值时，为了维护线段树，我们需要将每个与该范围相关的范围都修改一遍。如我要将1–8全部+3,那我需要将所有结点的w值都改变，这的操作数（15）已经比直接将8个元素+3的操作数（8）还多了。而懒标记就是来优化这个过程的，可以将懒标记当作一个待加值。如果我们暂时还用不到后面的值，这个待加值先暂时存储在他的父节点上，如果后面有相关的问询或修改要用到后面的结点，那这待加值顺带就给它加上，这样会避免每改一个值都将相关的范围结点改一遍，而一些根本用不到的结点也去改变就会浪费很多时间，所以先把这个待加值记在父结点上，如果后续操作需用到父节点的儿子，那时在加上也不迟，这样就确保了我们每次改变的结点都是我们需要用到的，不会有多余的浪费。 线段树基本操作一个结点 建树 按着二分的思路往下递归，直到范围为一个元素赋值 单点查询 和二分一样发现点在左边查询左子树，点在右边查询右子树直到找到该点 单点修改 范围查询对区域[x,y]的和的查询当前结点表示的范围[l,r]发现要查询的区域完全包含当前结点(x &lt;= tree[k].l &amp;&amp; y &gt;= tree[k].r) 直接加上当前结点的值 令mid = (tree[k].l + tree[k].r) / 2 如果(x&lt;=mid) 则表示在当前结点左儿子表示的范围中包含查询区域的部分或全部值，对左儿子查询加上其返回的值 如果(y &gt; mid) 则表示在当前结点右儿子表示的范围中包含查询区域的部分或全部值，对右儿子查询加上其返回的值 如： 构造的线段树还是原来这个查询[2,6]的值 此时在1号结点，不满足全部包含mid=(1+8)/2=4x&lt;=mid 左段包含y&gt;mid+1 右段包含 分成两段再次问询 此时在1*2=2号结点，不满足全部包含mid=(1+4)/2=2x&lt;=mid 左段包含y&gt;mid+1 右段包含 继续模拟即可…… 范围修改 线段树模板 线段树入门题    第一题源码 第二题源码 第三题源码 第四题源码 "},{"title":"算法","date":"2021-10-15T16:00:00.000Z","url":"/2021/10/16/%E7%BB%99%E7%A7%8B%E6%8B%9B%E5%8A%A0%E7%82%B9%E6%96%99%E2%80%94%E2%80%94Hot15%E9%81%93%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%81/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["面试题","/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"]],"categories":[["undefined",""]],"content":"@TOC 1.链表篇反转链表难度：easy 考察次数：189 传送门 题目描述输入一个链表，反转链表后，输出新链表的表头。 思路:创建三个指针，一个表示前一个结点pre，一个表示当前节点cur，一个表示后一个节点next。循环next=cur-&gt;next，cur-&gt;next=pre，pre=cur，cur=next，直到当前节点为NULL。 判断链表中是否有环难度：easy 考察次数：120 传送门 题目描述判断给定的链表中是否有环。如果有环则返回true，否则返回false。你能给出空间复杂度的解法么？ 思路：采用快慢指针解决，慢指针每次向前移动一步，快指针每次向前移动2步，如果链表中有环，快慢指针一定会相遇，注意一下溢出，判断快指针的下一步是不是NULL，如果为NULL则fast-&gt;next-&gt;next就溢出了。 合并有序链表难度： middle 考察次数：57 传送门 题目描述 将两个有序的链表合并为一个新链表，要求新的链表是通过拼接两个链表的节点来生成的，且合并后新链表依然有序。 思路：先确定表头，创建一个cur表示当前指针，之后比较两个链表表头节点，每次都让cur-&gt;next=较小表头的指针，并让该指针移动到其next，直到某链表为空，将剩余链表全部接到cur后面即可。 AC code 2.动态规划篇跳台阶难度: easy 考察次数： 55 传送门 题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 思路： d[i]表示从0到第i个台阶总共的方案数。转移方程：dp[i]=dp[i-1]+dp[i-2]，因为当前台阶可以由前两级台阶走到，初始dp[0]=1,dp[1]=1。 AC code 子数组的最大累加和难度：easy 考察次数：52 传送门 题目描述 给定一个数组arr，返回子数组的最大累加和例如，arr = [1, -2, 3, 5, -2, 6, -1]，所有子数组中，[3, 5, -2, 6]可以累加出最大的和12，所以返回12.题目保证没有全为负数的数据[要求]时间复杂度为O(n)O(n)O(n)，空间复杂度为O(1)O(1)O(1) 思路：dp[i]为以第i个元素为结尾的最大累加和，状态转移方程：dp[i]=max(dp[i-1]+arr[i]，arr[i])，从这可看出其实dp[i]只与dp[i-1]有关，所以对于dp的存储只需要一个空间，每次更新当前dp即可dp(相当于更新后的dp[i])=max(dp(相当于dp[i-1])+arr[i]，arr[i])。 AC code 求路径难度：easy 考察次数：15 传送门 题目描述 一个机器人在m×n大小的地图的左上角（起点）。机器人每次向下或向右移动。机器人要到达地图的右下角（终点）。可以有多少种不同的路径从起点走到终点？ 备注：m和n小于等于100,并保证计算结果在int范围内 思路： dp[i][j]表示走到 位置 i,j 的路径数，状态转移方程 dp[i][j]=dp[i-1][j]+dp[i][j-1] ，注意边界的处理情况。 AC code 最长公共子串难度：middle 考察次数：52 传送门 题目描述给定两个字符串str1和str2,输出两个字符串的最长公共子串题目保证str1和str2的最长公共子串存在且唯一。 思路： dp[i][j]代表str1串第以第i个字符结尾和str2串的公共串长度。状态转移方程：如果：str1[i]==str2[j]，dp[i][j]=dp[i-1][j-1]+1,如果str1[i]!=str2[j]，dp[i][j]=0。然后题目求的是最长串，那我们只需记录哪时dp[i][j]最大，最长公共串即为此时的i向前取dp[i][j]长度。 AC code 3.树篇两个节点最近公共祖先难度：middle 考察次数：32 传送门 题目描述给定一棵二叉树以及这棵树上的两个节点 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。 思路： 用一个map[i]记录以当前节点i为根，如果子树有一个所要求的节点则map[i]=1,两个则map[i]=2，从根节点深度优先搜索，第一个map为二的节点即为最近的公共祖先。 AC code 实现二叉树先中后序排列难度：middle 考察次数：97 传送门 题目描述分别按照二叉树先序，中序和后序打印所有的节点。 思路： 深度优先搜索，先序遍历即每到一个节点优先访问当前的节点值，后续遍历最后访问当前节点值，中序遍历先访问左节点再访问当前节点值最后访问右节点。 AC code 二叉树之字形遍历难度：middle 考察次数：37 传送门 题目描述给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）例如：给定的二叉树是{3,9,20,#,#,15,7}, 该二叉树之字形层序遍历的结果是 思路： 每次遍历一层的节点保存到一个列表中，然后下一层要从相反方向遍历，那么只需从当前层的后面往前面遍历子节点即可（每个下一层都是前一层的相反方向就实现了之字形遍历了），还要注意每次到新的一层要改变一下遍历方向，比如这层先遍历左节点再右节点，下层先右节点再左节点。 AC code 4.二分篇求平方根难度：easy 考察次数：27 传送门 题目描述实现函数 int sqrt(int x).计算并返回x的平方根（向下取整） 思路： 初始化l=0,r=x。直接暴力二分100次，mid=(l+r)/2，如果mid*mid&lt;=x , l=x , 如果mid*mid&gt;x ， r=mid。 AC code 5.其他岛屿数量难度：middle 考察次数：24 传送门 题目描述 给一个01矩阵，1代表是陆地，0代表海洋， 如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。岛屿: 相邻陆地可以组成一个岛屿（相邻:上下左右） 判断岛屿个数。 思路： 用一个book[i][j]记录之前有没有遍历过该处，然后把整个矩阵暴力dfs一遍，遇到lst[i][j]==1则dfs该处，如果该处四周的元素有值为1的，则接着dfs搜索下去每搜索一个地方记录。最后当全部都遍历一遍看需要从矩阵进入遍历几次即为岛屿数量。 AC code 最长无重复子串难度：middle 考察次数：52 传送门 题目描述给定一个数组arr，返回arr的最长无的重复子串的长度(无重复指的是所有数字都不相同)。 思路：尺取法，用两个坐标记录当前子串前后，每次将前面的坐标往前挪动一格，发现有重复的则将后面的坐标往前收缩直到无重复。 AC code 括号生成难度：middle 考察次数：13 传送门 题目描述给出n对括号，请编写一个函数来生成所有的由n对括号组成的合法组合。例如，给出n=3，解集为：“((()))”, “(()())”, “(())()”, “()()()”, “()(())”, 思路：回溯+剪枝，用一个open代表左括号，close代表右括号，然后dfs遍历所有情况，细节见代码。 AC code 有重复数字的所有排列难度：middle 考察次数：11 传送门 题目描述给出一组可能包含重复项的数字，返回该组数字的所有排列。 思路：回溯，标记好哪个数字被使用与否，暴力dfs，用一个map记录出现过的排列。 AC code "},{"title":"循环链表解决约瑟夫斯问题","date":"2021-10-15T06:42:35.223Z","url":"/2021/10/15/C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E8%A7%A3%E5%86%B3%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98/","tags":[["c++","/tags/c/"],["算法","/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["undefined",""]],"content":"循环链表解决约瑟夫斯问题问题描述：设有n个人围坐成一个圆圈，按一定指向方向，从第s个人开始报数，数到m的人出列，然后从下一个人重新报数，数到m的人又出列，…，直到n个人全部出列为止。输入：n m s，按次序输出得到的n个人的顺序表。 "},{"title":"八皇后问题","date":"2021-10-15T06:42:13.078Z","url":"/2021/10/15/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/","tags":[["c++","/tags/c/"],["算法","/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["undefined",""]],"content":" 八皇后问题（链接） 努比亚和苏丹没有子女，所以他要从一些有集成资格的继承者中挑选一个出来继承王位。他希望这个继承者足够聪明，所以他准备了一个西洋棋盘，上面的每个格子中均有一个 $1-99$ 的数字。他又准备了 $8$ 个皇后棋子。 $8$ 皇后的规则就是不能有任何棋子同行或者同列或者同斜线，在满足这个规则的同时，王位继承者还需要让 $8$ 个皇后所在的位置的数字的和是最大的。 输入格式 输入一个数字 $k(k\\leq 20)$，代表棋盘的数量。 接下来有 $k$ 个棋盘，每个棋盘有 $64$ 个数字，分成 $8$ 行 $8$ 列出入，具体可见样例，每一个数字均小于 $100$。输出格式 每一个棋盘对应输出最大的数值， 一共输出 $k$ 行。 源码如下 "},{"title":"二叉树顺序存储、链式存储及之间的转化","date":"2021-10-15T06:42:13.075Z","url":"/2021/10/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E3%80%81%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%8F%8A%E4%B9%8B%E9%97%B4%E8%BD%AC%E5%8C%96%E4%B8%8E%E9%81%8D%E5%8E%86%E3%80%82/","tags":[["c++","/tags/c/"],["算法","/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["undefined",""]],"content":"二叉树顺序存储、链式存储及之间转化与遍历。二叉树的存储可用顺序存储方式和链式存储方式，其中顺序存储时存储地址相邻，空间利用率高，但不易进行元素的增删等操作。而链式存储方式的元素可随意存放，但其存储空间所占为数据元素和指针所占空间，存储空间利用率低。 数据图如下 完整程序–转化算法如下 数据图的运行结果 如有问题，欢迎指正。 相关参考资料《数据结构》—周颜军"},{"title":"二叉排序树的实现","date":"2021-10-15T06:42:13.073Z","url":"/2021/10/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/","tags":[["c++","/tags/c/"],["算法","/tags/%E7%AE%97%E6%B3%95/"]],"categories":[["undefined",""]],"content":"问题描述及要求 产生一个菜单驱动的演示程序，用以说明二叉树的使用。元素由单个键组成，键为单个字符。用户能演示的二叉树基本操作至少包括：构造二叉树，按先序、中序、后序、层序遍历这棵二叉树，求二叉树的深度、宽度，统计度为0，1，2的结点数等。二叉树采用链式存储结构。对二叉查找树做上述工作，且增加以下操作：插入、删除给定键的元素、查找目标键。 由于没使用类模板，请使用二叉树演示时此处为char而使用二叉排序树时将char 改为int。 Code "},{"title":"文字交互电子宠物游戏","date":"2021-10-14T14:48:02.261Z","url":"/2021/10/14/%E7%94%B5%E5%AD%90%E5%AE%A0%E7%89%A9%E6%B8%B8%E6%88%8F%EF%BC%88%E9%99%84C++%E6%BA%90%E7%A0%81%EF%BC%89/","tags":[["c++","/tags/c/"]],"categories":[["undefined",""]],"content":" 设计一款文字式交互电子宠物游戏，该游戏要求具备如下要素： 一、玩家（Player），玩家具备如下要素：体力：体力是玩家行动的关键要素，玩家最高拥有100点体力值，每种不同行动都会消耗体力，一旦体力归0，玩家只能选择休息恢复体力。 金钱：金钱是购买宠物道具的要素，金钱可以通过打工获取。 行动：玩家可以在一个时间点选择一个行动，每种行动均会获取一定内容并且消耗当前时间： 1)打工，打工会消耗玩家体力，收获金钱，消耗时间。家教，消耗2个时间，获取50金钱，消耗30体力麦当劳兼职，消耗个4时间，获取120金钱，消耗70体力割草，消耗1个时间，获取20金钱，消耗20体力请你设计。 2)购买宠物粮食，玩家消耗1个时间，20体力，根据具体宠物粮食消耗金钱。 3)喂食：玩家消耗1个时间，20体力。 4)休息，玩家消耗1个时间，恢复50体力。 5)和宠物玩耍：玩家消耗1个时间，50体力。 6)清洗宠物：玩家消耗1个时间，30体力。 7)每天结束时，玩家会进入睡眠状态，睡眠会恢复玩家全部体力，并进入下一天。 二、宠物（Pet），当前电子系统仅支持宠物猫（Cat）和宠物狗（Dog）两种宠物，但是系统必须拥有扩展宠物的能力，宠物具备如下要素： 性别：公/母 饱食度：宠物的饱食度为0时，会降低10点愉悦度，猫会降低1斤体重，狗会降低2斤体重。宠物饱食度为100时，猫会提高1斤体重，狗会提高2斤体重。宠物被喂食会根据投喂的食物提高一定饱食度。宠物玩耍后会根据玩耍和宠物自身情况降低饱食度。 愉悦度：愉悦度影响宠物对玩家的态度，愉悦度为0时，宠物会离开主人；愉悦度低于30时，宠物不会和主人玩耍；愉悦度低于70时，宠物狗不会让主人清洗；宠物猫的愉悦度必须90以上，才会让主人清洗。 体重：体重是衡量宠物的健康，公猫健康体重为812斤，初始时公猫为10斤，母猫健康体重为48斤，初始时母猫为6斤。公猫体重低于4斤，高于16斤将会因为健康不佳死亡，母猫体重低于2斤，高于10斤将会因为健康死亡。狗健康体重为30~60斤，初始时狗会有45斤体重。低于15斤，高于75斤，狗会因为健康死亡。宠物低于超出健康体重时，每个时间段都会降低10点愉悦度。 清洁度：清洁度为0时，宠物愉悦度每个时间段降低30，清洁度高于80时，宠物愉悦度每个时间段升高10。 宠物行为：1)玩耍：宠物狗玩耍时，会消耗40点饱食度，提高70点愉悦度，降低10点清洁度。宠物猫玩耍时，会消耗20点饱食度，提高30点愉悦度（猫是高冷的），降低10点清洁度。 2)叫：狗是汪汪叫，猫是喵喵叫（这里只需要printf信息表示即可） 3)喂食：消耗1个时间，喂食时，宠物会先叫，然后会根据提供食物不同获取属性。 4)猫的自洁：猫有30%的可能性进行自洁，消耗1个时间，提高30清洁度； 5)猫的随机抓老鼠：在任何时间段，猫有20%的可能会去抓老鼠，此时主人是无法对猫进行交互的。消耗1个时间，如果此时猫的饱食度低于50，会吃掉老鼠，提高40饱食度，降低30清洁度，提高5愉悦度。如果此时猫的饱食度大于等于50，猫只会玩耍老鼠，降低20饱食度，降低10清洁度，提高40愉悦度。 6)被主人清洁：消耗1个时间，提高100清洁度。但是对于猫，清洁度高于80或清洁间隔低于30个时间段时，不接受被主人清洁，强行清洁会降低50愉悦度（猫主子不喜欢） 7)非主人交互时间：该时间段一般为主人买东西、打工或休息等无暇顾及宠物的时间段，该时间段内宠物将降低20饱食度，另外，狗降低20点愉悦度，和20点清洁度。猫不会降低愉悦度，但是会降低5清洁度。 8)每天结束时，宠物会强制进入休息，提高30愉悦度，降低5清洁度，降低60饱食度。 三、宠物食物粗糙的粮食：花费30金钱，为宠物提供30体力，10愉悦度，降低15清洁度；精品粮食：花费60金钱，为宠物提供50体力，40愉悦度，降低5清洁度；香肠：花费20金钱，为宠物提供20体力，30愉悦度，降低20清洁度；其他可自行设计 四、系统游戏开始时，系统给予玩家选择宠物和宠物性别的机会 一天提供7个时间段给玩家选择行动方案，一旦玩家选择并确定某种行动方案，视作时间段开始，此时，时间会发生对应的流逝。每个时间段开始前，系统必须显示当时玩家和宠物的状态。 一旦宠物死亡，游戏结束。三十天后，宠物依然健康，游戏结束，并结算显示宠物状态。 系统提供存档、读档、关闭、重新开始等功能 效果图如下： 源码如下(可直接运行) "},{"title":"飞翔小鸟游戏（java实现）","date":"2021-10-14T14:47:29.891Z","url":"/2021/10/14/java400%E8%A1%8C%E8%83%BD%E5%B9%B2%E5%95%A5%EF%BC%9F%E4%B8%8D%E5%A6%82%E5%86%99%E4%B8%AA%E9%A3%9E%E7%BF%94%E5%B0%8F%E9%B8%9F%E6%B8%B8%E6%88%8F%E5%90%A7/","categories":[["undefined",""]],"content":"声明：该项目是牛客网的一个开源项目 @TOC 文章目录一 效果图 ![在这里插入图片描述]() 二 思维导图1.类的属性关系 2.类的相关方法 三 设计步骤1.素材准备相关项目/素材我放到了github仓库。github地址 网盘链接 提取码：rikk 2.预备知识及其运用1.面向对象的封装：设计包装出小鸟、地面、柱子、游戏四个类。2.swing和awt包：图形界面工具，绘制出游戏场景。3.Math类：运用atan等方法辅助完成小鸟旋转角度转换。4.事件监听器：运用鼠标监听器完成游戏状态转换及小鸟移动。5.多线程：该项目就用到了一个sleep休眠。 相关的知识用到的不多，一边做一边学习(熟悉)运用就好。 3.大体流程1.绘制面板，放入背景图。2.设计地面、柱子类完成移动的效果(移动方法实现)。3.设计小鸟，完成飞行轨迹、与柱子是否碰撞的方法等。4.设计游戏类，完成游戏类界面的绘制。5.设计游戏开始的方法与流程。6.增加鼠标监听器完成对小鸟飞行及游戏运行的控制。 四 源码1.游戏类 2.地面类 3.小鸟类 4.柱子类"}]